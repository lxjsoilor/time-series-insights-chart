/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ TimeSeriesInsightsChart; }\n/* harmony export */ });\nconst countDown = (start, end) => {\n  if (start === end) return \"0秒\";\n  var startDate = +new Date(start);\n  var endDate = +new Date(end);\n  var dec = (endDate - startDate) / 1000;\n  var d = parseInt(dec / 60 / 60 / 24);\n  d = d < 10 ? \"0\" + d : d;\n  var h = parseInt(dec / 60 / 60 % 24);\n  h = h < 10 ? \"0\" + h : h; //得到分钟 格式化成前缀加零的样式\n\n  var m = parseInt(dec / 60 % 60);\n  m = m < 10 ? \"0\" + m : m;\n  var s = parseInt(dec % 60);\n  s = s < 10 ? \"0\" + s : s;\n\n  if (d > 0) {\n    return `${d}天${h}时${m}分${s}秒`;\n  }\n\n  if (h > 0) {\n    return `${h}时${m}分${s}秒`;\n  }\n\n  if (m > 0) {\n    return `$${m}分${s}秒`;\n  }\n\n  if (s > 0) {\n    return `${s}秒`;\n  }\n};\n\nconst log = arg => {\n  try {\n    console.log(JSON.parse(JSON.stringify(arg)));\n  } catch (e) {\n    console.log(arg);\n  }\n};\n\nconst OperationUtils = {\n  add: function (arg1, arg2) {\n    return arg1 + arg2;\n    var r1, r2, m;\n\n    try {\n      r1 = arg1.toString().split(\".\")[1].length;\n    } catch (e) {\n      r1 = 0;\n    }\n\n    try {\n      r2 = arg2.toString().split(\".\")[1].length;\n    } catch (e) {\n      r2 = 0;\n    }\n\n    m = Math.pow(10, Math.max(r1, r2));\n    return (OperationUtils.multiply(arg1, m) + OperationUtils.multiply(arg2, m)) / m;\n  },\n  sub: function (arg1, arg2) {\n    return arg1 - arg2;\n    var r1, r2, m, n;\n\n    try {\n      r1 = arg1.toString().split(\".\")[1].length;\n    } catch (e) {\n      r1 = 0;\n    }\n\n    try {\n      r2 = arg2.toString().split(\".\")[1].length;\n    } catch (e) {\n      r2 = 0;\n    }\n\n    m = Math.pow(10, Math.max(r1, r2)); // 动态控制精度长度\n\n    n = r1 >= r2 ? r1 : r2;\n    return ((OperationUtils.multiply(arg1, m) - OperationUtils.multiply(arg2, m)) / m).toFixed(n);\n  },\n  multiply: function (arg1, arg2) {\n    return arg1 * arg2;\n\n    if (arg1 == null || arg2 == null) {\n      return null;\n    }\n\n    var n1, n2;\n    var r1, r2; // 小数位数\n\n    try {\n      r1 = arg1.toString().split(\".\")[1].length;\n    } catch (e) {\n      r1 = 0;\n    }\n\n    try {\n      r2 = arg2.toString().split(\".\")[1].length;\n    } catch (e) {\n      r2 = 0;\n    }\n\n    n1 = Number(arg1.toString().replace(\".\", \"\"));\n    n2 = Number(arg2.toString().replace(\".\", \"\"));\n    return n1 * n2 / Math.pow(10, r1 + r2);\n  },\n  divide: function (arg1, arg2) {\n    return arg1 / arg2;\n\n    if (arg1 == null) {\n      return null;\n    }\n\n    if (arg2 == null || arg2 == 0) {\n      return null;\n    }\n\n    var n1, n2;\n    var r1, r2; // 小数位数\n\n    try {\n      r1 = arg1.toString().split(\".\")[1].length;\n    } catch (e) {\n      r1 = 0;\n    }\n\n    try {\n      r2 = arg2.toString().split(\".\")[1].length;\n    } catch (e) {\n      r2 = 0;\n    }\n\n    n1 = Number(arg1.toString().replace(\".\", \"\"));\n    n2 = Number(arg2.toString().replace(\".\", \"\"));\n    return n1 / n2 * Math.pow(10, r2 - r1);\n  }\n};\nconst DEFAULT_CONFIG = {\n  itemHeight: 200,\n  colors: [\"#FF6410\", \"#00BAF1\", \"#00FF23\", \"#FE004C\", \"#0052DF\", \"#F9CA53\"],\n  padding: [10, 10, 0, 0],\n  line: {\n    pointsPow: 10\n  },\n  yLabel: {\n    isRounding: true,\n    line: {\n      show: true,\n      num: 5,\n      lineColor: \"#ffffffff\",\n      width: 0\n    },\n    font: {\n      size: 14,\n      color: \"#FFFFFF\",\n      family: \"Arial\",\n      padding: [0, 10, 0, 10]\n    }\n  },\n  xLabel: {\n    line: {\n      show: true,\n      num: 2,\n      lineColor: \"#333\",\n      width: 0\n    },\n    font: {\n      size: 14,\n      color: \"#FFFFFF\",\n      family: \"Arial\",\n      padding: [10, 0, 10, 0]\n    }\n  },\n  menus: {\n    background: \"#FFFFFF\",\n    fontColor: \"#000000\"\n  },\n  chooseBox: {\n    background: \"rgba(50, 50, 200, 0.5)\",\n    topBackground: \"#01BAF5\",\n    topFontColor: \"#000000\",\n    bottomBackground: \"#FFFEFF\",\n    bottomFontColor: \"#000000\"\n  },\n  statistics: {\n    fontColor: \"#FFFEFF\"\n  },\n  horizontalLine: {\n    color: \"#898B8F\",\n    backgroundColor: \"#FFFFFF\",\n    fontColor: \"#000000\"\n  },\n  verticalLine: {\n    color: \"#898B8F\",\n    backgroundColor: \"#FFFFFF\",\n    fontColor: \"#000000\"\n  }\n};\nclass TimeSeriesInsightsChart {\n  constructor(opts) {\n    this.dpr = 1;\n    this.canvas = opts.canvas;\n    this.onMemuSelected = opts.onMemuSelected;\n    this.ctx = null;\n    this.data = opts.data;\n    this.originData = opts.data;\n    this.currentData = [];\n    this.dataValueMax = [];\n    this.dataValueMin = [];\n    this.config = Object.assign(DEFAULT_CONFIG, opts.config);\n    this.yLabel = [];\n    this.xLabel = [];\n    this.currentPoints = []; // 鼠标按下\n\n    this.mouseDown = false;\n    this.mouseDownPoint = {}; // 鼠标移动\n\n    this.mouseMove = false;\n    this.mouseMovePoint = {}; // 鼠标抬起\n\n    this.mouseUp = true;\n    this.mouseUpPoint = {};\n    this.menuListInvalidArea = {};\n    this.mousedownTimer = 0;\n    this.currentSelectedDataItemIndex = 0;\n    this.horizontalLineItem = {}; // 同时选取\n\n    this.sameTimeSelect = false;\n\n    this.dataChangeListener = () => {};\n  }\n\n  init(width, height) {\n    this.initChart(width, height);\n    this.initListener();\n  }\n\n  setDataChangeListener(fn) {\n    this.dataChangeListener = fn;\n  }\n\n  setWidth(width) {\n    if (width) {\n      this.initChart(width, this.canvas.height);\n    }\n\n    this.draw();\n  }\n\n  setHeight(height) {\n    if (height) {\n      this.initChart(this.canvas.width, height);\n    }\n\n    this.draw();\n  }\n\n  setSameTimeSelect(bool) {\n    this.sameTimeSelect = bool;\n    this.mouseDown = false;\n  }\n\n  setOriginData(data) {\n    this.originData = data;\n  }\n\n  setCanvas(canvas) {\n    this.canvas = canvas;\n  }\n\n  initChart(width = 1593, height = 600) {\n    this.setSelectData(this.originData);\n    this.canvas.width = width;\n    const length = this.originData.length;\n    let newHeight = height;\n\n    if (length > 3) {\n      newHeight = height + height / 3 * (length - 3);\n    }\n\n    this.canvas.height = newHeight;\n    this.ctx = this.canvas.getContext(\"2d\");\n  }\n\n  initListener() {\n    const eventsName = [\"mousedown\", \"mouseup\", \"mousemove\"];\n    eventsName.forEach(item => {\n      this.canvas.addEventListener(item, e => {\n        this[item + \"Event\"](e);\n      }, false);\n    });\n  }\n\n  mousedownEvent(e) {\n    const pos = this.getCanvasPos(this.canvas, e); // 判断是否鼠标在菜单范围内\n    // 绘制选中的点\n\n    if (!this.isInside(this.menuListInvalidArea, pos.x, pos.y)) {\n      this.mouseDownPoint = { ...this.getNearX(pos),\n        sourcePoint: pos\n      };\n      this.mousedownTimer = setTimeout(() => {\n        this.mouseDown = true;\n      }, 100);\n      this.mouseMove = false;\n      this.mouseUp = false;\n      this.setCurrentSelectedDataItemIndex(pos.y);\n      this.drawCurrentPointAndLine({\n        x: this.mouseDownPoint.x,\n        y: pos.y\n      });\n      this.drawCurrentPointToolBar({\n        x: this.mouseDownPoint.x,\n        y: pos.y\n      });\n    } else {\n      this.listenMenuListClick(pos.x, pos.y);\n    }\n  }\n\n  setCurrentSelectedDataItemIndex(y) {\n    let index = -1;\n    this.yLabel.forEach((item, i) => {\n      if (y <= item[0].y && index === -1) {\n        index = i;\n      }\n    });\n    this.currentSelectedDataItemIndex = index;\n  }\n\n  mousemoveEvent(e) {\n    if (!this.sameTimeSelect) return;\n    this.mouseMove = true;\n\n    if (this.mouseDown) {\n      const pos = this.getCanvasPos(this.canvas, e);\n      this.mouseMovePoint = { ...this.getNearX(pos),\n        sourcePoint: pos\n      }; // 开始绘制\n\n      this.drawChooseBox();\n    }\n  }\n\n  mouseupEvent(e) {\n    if (!this.sameTimeSelect) return;\n    clearTimeout(this.mousedownTimer);\n    const pos = this.getCanvasPos(this.canvas, e);\n    this.mouseUpPoint = { ...this.getNearX(pos),\n      sourcePoint: pos\n    };\n\n    if (this.mouseMove && this.mouseDown) {\n      // 画菜单\n      if (!this.isInside(this.menuListInvalidArea, pos.x, pos.y)) {\n        this.drawMenuList();\n      }\n    }\n\n    this.mouseDown = false;\n    this.mouseMove = false;\n    this.mouseUp = true;\n  }\n\n  drawMenuList() {\n    const nameStart = this.mouseDownPoint.name;\n    const nameEnd = this.mouseUpPoint.name;\n    const indexStart = this.originData[0].findIndex(({\n      name\n    }) => name === nameStart);\n    const indexEnd = this.originData[0].findIndex(({\n      name\n    }) => name === nameEnd);\n    if (Math.abs(indexStart - indexEnd) < 2) return; // 画菜单\n\n    const menus = [\"缩放\", \"查看统计数据\", \"导出数据\"];\n    const menusItemHeight = 30;\n    const height = menusItemHeight * menus.length;\n    const {\n      x: downX,\n      y: downY,\n      sourcePoint: downSourcePoint\n    } = this.mouseDownPoint;\n    const {\n      x: upX,\n      y: upY,\n      sourcePoint: upSourcePoint\n    } = this.mouseUpPoint;\n    const width = 100;\n    this.ctx.save(); // 画菜单背景\n\n    this.ctx.fillStyle = this.config.menus.background;\n    const rectHeight = upSourcePoint.y - downSourcePoint.y;\n    let bgX = upX + 10;\n\n    if (bgX > this.canvas.width - 100) {\n      bgX = bgX - 100 - 10;\n    }\n\n    const bgY = upSourcePoint.y - height / 2 - rectHeight / 2;\n    this.ctx.fillRect(bgX, bgY, 100, height); // 画菜单内容\n\n    const padding = 10;\n    menus.forEach((text, index) => {\n      const fontX = bgX + padding;\n      const fontY = bgY + height / (2 * menus.length) + height * index / menus.length;\n      this.ctx.textAlign = \"start\";\n      this.ctx.font = \"12px Arial\";\n      this.ctx.fillStyle = this.config.menus.fontColor;\n      this.ctx.textBaseline = \"middle\";\n      this.ctx.fillText(text, fontX, fontY);\n    }); //\n\n    this.setMenuListInvalidArea(bgX, bgY, 100, height, menus);\n    this.ctx.restore();\n  }\n\n  listenMenuListClick(clickX, clickY) {\n    // 判断clickY 在哪个菜单上\n    const {\n      x,\n      y,\n      w,\n      h,\n      menus\n    } = this.menuListInvalidArea;\n    const index = Math.ceil((y + h - clickY) / (h / menus.length));\n    const selected = menus[menus.length - index];\n    const nameStart = this.mouseDownPoint.name;\n    const nameEnd = this.mouseUpPoint.name;\n    const indexStart = this.originData[0].findIndex(({\n      name\n    }) => name === nameStart);\n    const indexEnd = this.originData[0].findIndex(({\n      name\n    }) => name === nameEnd);\n    let start;\n    let end;\n\n    if (indexStart > indexEnd) {\n      start = indexEnd;\n      end = indexStart;\n    } else {\n      start = indexStart;\n      end = indexEnd;\n    }\n\n    const newData = JSON.parse(JSON.stringify(this.originData));\n    newData.forEach((item, index) => {\n      newData[index] = item.splice(start, end - start);\n    });\n\n    if (selected === \"缩放\") {\n      this.setSelectData(newData);\n      this.draw();\n    }\n\n    if (selected === \"查看统计数据\") {\n      this.draw();\n      this.drawChooseBox();\n      this.drawCurrentPointStatistics({\n        x: this.mouseUpPoint.x,\n        y: this.mouseDownPoint.sourcePoint.y\n      });\n    }\n\n    this.onMemuSelected && this.onMemuSelected(selected, newData);\n  }\n\n  setMenuListInvalidArea(x, y, w, h, menus) {\n    this.menuListInvalidArea = {\n      x,\n      y,\n      w,\n      h,\n      menus\n    }; // this.ctx.rect(x, y, w, h);\n  }\n\n  drawChooseBox() {\n    this.menuListInvalidArea = {};\n    this.clearCanvas();\n    this.draw();\n    const {\n      x,\n      y,\n      sourcePoint,\n      name\n    } = this.mouseDownPoint;\n    const {\n      x: x2,\n      y: y2,\n      sourcePoint: sourcePoint2,\n      name: name2\n    } = this.mouseMovePoint;\n    this.drawVerticalLine(x);\n    this.drawVerticalLine(x2);\n    this.drawDots(x, \"mouseDownPoint\");\n    this.drawDots(x2, \"mouseMovePoint\");\n    this.ctx.save();\n    this.ctx.fillStyle = this.config.chooseBox.background;\n    this.ctx.fillRect(x, sourcePoint.y, x2 - x, sourcePoint2.y - sourcePoint.y); // 画选框顶部文字\n\n    this.ctx.fillStyle = this.config.chooseBox.topBackground;\n    this.ctx.textAlign = \"center\";\n    this.ctx.font = \"12px Arial\";\n    this.ctx.textBaseline = \"top\"; // 画文字背景\n\n    let text1;\n\n    if (x2 > x) {\n      text1 = `${countDown(name, name2)}`;\n    } else {\n      text1 = `${countDown(name2, name)}`;\n    }\n\n    const width = this.ctx.measureText(text1).width * 1.2;\n    this.ctx.fillRect(x + (x2 - x) / 2 - width / 2, sourcePoint.y - 5, width, 20);\n    this.ctx.fillStyle = this.config.chooseBox.topFontColor;\n    this.ctx.fillText(text1, x + (x2 - x) / 2, sourcePoint.y); // 画选框底部文字\n\n    this.ctx.textBaseline = \"bottom\";\n    let text2 = `${name}`;\n    let text3 = `${name2}`;\n\n    if (x2 > x) {\n      text3 = `${name}`;\n      text2 = `${name2}`;\n    }\n\n    const width2 = this.ctx.measureText(text2).width * 1.2;\n    this.ctx.fillStyle = this.config.chooseBox.bottomBackground;\n    this.ctx.fillRect(x + (x2 - x) / 2 - width2 / 2, sourcePoint2.y - 30, width2, 30);\n    this.ctx.fillStyle = this.config.chooseBox.bottomFontColor;\n    this.ctx.fillText(text2, x + (x2 - x) / 2, sourcePoint2.y);\n    this.ctx.fillText(text3, x + (x2 - x) / 2, sourcePoint2.y - 15);\n    this.ctx.restore();\n  } // 清除当前画布\n\n\n  clearCanvas() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  isInside(rect, x, y) {\n    if (!rect.x) return false;\n\n    if (x > rect.x && x < rect.x + rect.w && y > rect.y && y < rect.y + rect.h) {\n      return true;\n    }\n\n    return false;\n  } // 获取最近的一个坐标点\n  // 找到距离当前点击位置最近的坐标点 x 轴\n\n\n  getNearX({\n    x,\n    y\n  }) {\n    let point;\n    let difference = +Infinity;\n    this.currentPoints.forEach(item => {\n      let currentDifference = Math.abs(x - item.x);\n\n      if (currentDifference <= difference) {\n        point = item;\n        difference = currentDifference;\n      }\n    });\n    return { ...point\n    };\n  } // 画统计栏\n\n\n  drawCurrentPointStatistics({\n    x,\n    y\n  }) {\n    // 画背景\n    const {\n      x: x2,\n      name: startName\n    } = this.mouseDownPoint;\n    const {\n      name: endName\n    } = this.mouseUpPoint;\n    let infos = [];\n    this.ctx.save();\n    this.ctx.fillStyle = \"rgba(50, 50, 60, 0.8)\";\n    const count = this.originData.length;\n    const width = 300;\n    const titleHeight = 80;\n    const contextHeight = 80 * count;\n    const height = titleHeight + contextHeight;\n    const horPadding = 10;\n    let direction = horPadding;\n    let newY = y - height / 2 + titleHeight;\n\n    if (this.canvas.width - x <= width) {\n      direction = -(horPadding + width);\n    }\n\n    let newX = x + direction;\n\n    if (newY < 0) {\n      newY = horPadding;\n    }\n\n    if (newY > this.canvas.height - height) {\n      newY = newY - height / 2 - horPadding;\n    }\n\n    let text = \"\";\n\n    if (x2 < x) {\n      text = `${countDown(startName, endName)}`;\n    } else {\n      text = `${countDown(endName, startName)}`;\n    }\n\n    this.ctx.fillRect(newX, newY, width, height); // 画标题\n\n    this.ctx.textAlign = \"start\";\n    this.ctx.fillStyle = this.config.statistics.fontColor;\n    this.ctx.textBaseline = \"middle\";\n\n    if (x2 < x) {\n      this.ctx.fillText(`${endName} -- ${startName}`, newX + horPadding, newY + titleHeight / 2 - 10);\n    } else {\n      this.ctx.fillText(`${startName} -- ${endName}`, newX + horPadding, newY + titleHeight / 2 - 10);\n    }\n\n    this.ctx.fillText(`${text}`, newX + horPadding, newY + titleHeight / 2 + 10);\n    this.currentData.forEach(data => {\n      data.forEach(item => {\n        if (item.name == endName) {\n          infos.push(item.info);\n        }\n      });\n    }); // 画内容\n\n    new Array(count).fill(true).forEach((item, index) => {\n      // 画线条\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = this.config.colors[index];\n      this.ctx.moveTo(newX + horPadding, newY + titleHeight + horPadding + contextHeight * index / count);\n      this.ctx.lineTo(newX + horPadding, newY + titleHeight + contextHeight * (index + 1) / count - horPadding);\n      this.ctx.closePath();\n      this.ctx.stroke(); // 画文字\n\n      this.ctx.textAlign = \"start\";\n      this.ctx.font = \"12px Arial\";\n      this.ctx.fillStyle = this.config.statistics.fontColor;\n      this.ctx.textBaseline = \"middle\";\n      const textHeight = 10;\n      const length = 75 - horPadding;\n      const lengthItem = length / 3;\n      const info = infos[index];\n      new Array(3).fill(true).forEach((item2, index2) => {\n        let infoText = \"22\";\n\n        if (index2 === 0) {\n          infoText = info.title;\n        }\n\n        if (index2 === 1) {\n          infoText = info.date;\n        }\n\n        if (index2 === 2) {\n          infoText = info.value;\n        }\n\n        this.ctx.fillText(infoText, newX + horPadding + horPadding, newY + titleHeight + horPadding + contextHeight * index / count + textHeight + lengthItem * index2);\n      });\n    });\n    this.ctx.restore();\n  }\n\n  drawCurrentPointToolBarFn(x, y, n) {\n    const {\n      name\n    } = this.mouseDownPoint;\n    let infos = [];\n    this.ctx.save();\n    this.ctx.fillStyle = \"rgba(50, 50, 60, 0.8)\";\n    const count = n;\n    const width = 200;\n    const height = 80 * count;\n    const horPadding = 10;\n    let direction = horPadding;\n    let newY = y - height / 2;\n\n    if (this.canvas.width - x <= width) {\n      direction = -(horPadding + width);\n    }\n\n    if (newY < 0) {\n      newY = horPadding;\n    }\n\n    if (newY > this.canvas.height - height) {\n      newY = newY - height / 2 - horPadding;\n    }\n\n    let newX = x + direction;\n    this.ctx.fillRect(newX, newY, width, height); // 画内容\n\n    if (this.count === 1) {\n      this.currentData[this.currentSelectedDataItemIndex].forEach(item => {\n        if (item.name == name) {\n          infos.push(item.info);\n        }\n      });\n    } else {\n      this.currentData.forEach(data => {\n        data.forEach(item => {\n          if (item.name == name) {\n            infos.push(item.info);\n          }\n        });\n      });\n    }\n\n    new Array(count).fill(true).forEach((item, index) => {\n      let color = this.config.colors[this.currentSelectedDataItemIndex];\n\n      if (count !== 1) {\n        color = this.config.colors[index];\n      } // 画线条\n\n\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = color;\n      this.ctx.moveTo(newX + horPadding, newY + horPadding + height * index / count);\n      this.ctx.lineTo(newX + horPadding, newY + height * (index + 1) / count - horPadding);\n      this.ctx.closePath();\n      this.ctx.stroke(); // 画文字\n\n      this.ctx.textAlign = \"start\";\n      this.ctx.font = \"12px Arial\";\n      this.ctx.fillStyle = this.config.statistics.fontColor;\n      this.ctx.textBaseline = \"middle\";\n      const textHeight = 10;\n      const length = 75 - horPadding;\n      const lengthItem = length / 3;\n      const info = infos[index];\n      new Array(3).fill(true).forEach((item2, index2) => {\n        let infoText = \"22\";\n\n        if (index2 === 0) {\n          infoText = info.title;\n        }\n\n        if (index2 === 1) {\n          infoText = info.date;\n        }\n\n        if (index2 === 2) {\n          infoText = info.value;\n        }\n\n        this.ctx.fillText(infoText, newX + horPadding + horPadding, newY + horPadding + height * index / count + textHeight + lengthItem * index2);\n      });\n    });\n    this.ctx.restore();\n  } // 画工具栏\n\n\n  drawCurrentPointToolBar({\n    x,\n    y\n  }) {\n    // 画背景\n    if (this.sameTimeSelect) {\n      this.drawCurrentPointToolBarFn(x, y, this.originData.length);\n      return;\n    }\n\n    this.drawCurrentPointToolBarFn(x, y, 1);\n  } // 画圆和线条\n\n\n  drawCurrentPointAndLine({\n    x,\n    y\n  }) {\n    this.clearCanvas();\n    this.draw(); // 画线条\n    // 画横线条\n\n    this.drawHorizontalLine();\n    this.drawHorizontalLineText(); // 画竖线条\n\n    this.drawVerticalLine(x); // 画圆\n\n    this.drawDots(x);\n  }\n\n  drawHorizontalLine() {\n    this.ctx.save();\n    this.ctx.lineWidth = 0.5;\n    this.ctx.strokeStyle = this.config.horizontalLine.color;\n    this.ctx.beginPath();\n    let y = this.getHorizontalLineItem().y;\n    this.ctx.moveTo(this.xLabel[0].x, y);\n    this.ctx.lineTo(this.canvas.width, y);\n    this.ctx.closePath();\n    this.ctx.stroke();\n    this.ctx.restore();\n  }\n\n  getHorizontalLineItem() {\n    const {\n      name\n    } = this.mouseDownPoint;\n\n    if (this.currentSelectedDataItemIndex === -1) {\n      return {};\n    }\n\n    this.currentData[this.currentSelectedDataItemIndex].forEach(item => {\n      if (item.name === name) {\n        this.horizontalLineItem = item;\n      }\n    });\n    return this.horizontalLineItem;\n  }\n\n  drawHorizontalLineText() {\n    const {\n      y,\n      value\n    } = this.getHorizontalLineItem();\n    const padding = 10;\n    this.ctx.save(); // 画背景\n\n    this.ctx.fillStyle = this.config.horizontalLine.backgroundColor;\n    const width = this.ctx.measureText(value.toFixed(3)).width + 2 * padding;\n    this.ctx.fillRect(this.xLabel[0].x, y - 10, width, 18); // 画文字\n\n    this.ctx.textAlign = \"start\";\n    this.ctx.font = \"12px Arial\";\n    this.ctx.fillStyle = this.config.horizontalLine.fontColor;\n    this.ctx.textBaseline = \"middle\";\n    this.ctx.fillText(value.toFixed(3), this.xLabel[0].x + padding, y);\n    this.ctx.restore();\n  }\n\n  drawDots(x, str = \"mouseDownPoint\") {\n    // 获取所有的y画所有的圆点\n    // 根据name 获取所有的y\n    const name = this[str].name; // 判断是否是同时选取\n\n    if (this.sameTimeSelect) {\n      const ys = this.currentData.map(data => {\n        let currentY;\n        data.forEach(item => {\n          if (item.name == name) {\n            currentY = item.y;\n          }\n        });\n        return currentY;\n      });\n      ys.forEach((y, index) => {\n        this.ctx.save();\n        this.ctx.fillStyle = this.config.colors[index];\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, 5, 0, Math.PI * 2, true);\n        this.ctx.closePath();\n        this.ctx.fill();\n        this.ctx.restore();\n      });\n      return;\n    }\n\n    const data = this.currentData[this.currentSelectedDataItemIndex];\n    let currentY;\n    data.forEach(item => {\n      if (item.name == name) {\n        currentY = item.y;\n      }\n    });\n    this.ctx.save();\n    this.ctx.fillStyle = this.config.colors[this.currentSelectedDataItemIndex];\n    this.ctx.beginPath();\n    this.ctx.arc(x, currentY, 5, 0, Math.PI * 2, true);\n    this.ctx.closePath();\n    this.ctx.fill();\n    this.ctx.restore();\n  }\n\n  drawVerticalLine(x) {\n    this.ctx.save(); // 画线条\n\n    this.ctx.lineWidth = 0.5;\n    this.ctx.strokeStyle = this.config.verticalLine.color; // 判断是否是同时选取\n\n    this.ctx.beginPath();\n\n    if (true) {\n      this.ctx.moveTo(x, 0);\n      this.ctx.lineTo(x, this.yLabel[this.originData.length - 1][0].y);\n    } else {}\n\n    this.ctx.closePath();\n    this.ctx.stroke();\n    this.ctx.restore();\n  }\n\n  setSelectData(data) {\n    this.data = data;\n    this.dataValueMax = [];\n    this.dataValueMin = [];\n    data.forEach(item => {\n      this.dataValueMax.push(item[0].value);\n      this.dataValueMin.push(item[0].value);\n    });\n    console.log(\"232323232323232323233\");\n    this.dataChangeListener(data);\n  }\n\n  draw() {\n    this.clearCanvas();\n\n    if (!this.data.length) {\n      return;\n    }\n\n    this.data.forEach((dataItem, index) => {\n      dataItem = JSON.parse(JSON.stringify(this.getNewData(dataItem)));\n      this.initCoordinateSystem(dataItem, index);\n      this.initData(dataItem, false, index);\n      this.drawCoordinateSystem(index);\n      this.drawLine(dataItem, index);\n      this.currentData[index] = dataItem;\n\n      if (index === 0) {\n        this.events(JSON.parse(JSON.stringify(dataItem)));\n      }\n    });\n  }\n\n  getStyles(obj) {\n    //兼容FF，IE10; IE9及以下未测试\n    return document.defaultView.getComputedStyle(obj);\n  }\n\n  getCanvasPos(canvas, e) {\n    var rect = canvas.getBoundingClientRect();\n    var leftB = parseInt(this.getStyles(canvas).borderLeftWidth); //获取的是样式，需要转换为数值\n\n    var topB = parseInt(this.getStyles(canvas).borderTopWidth);\n    return {\n      x: e.clientX - rect.left - leftB,\n      y: e.clientY - rect.top - topB\n    };\n  } // 事件相关\n\n\n  events(data) {\n    data = data.filter(item => {\n      return item.isReal;\n    });\n    this.currentPoints = data;\n    this.moveFlag = true;\n    this.canvas.addEventListener(\"touchmove\", e => {\n      if (this.moveFlag) {\n        this.moveFlag = false;\n        let clientX = e.changedTouches[0].clientX * this.dpr;\n        let point = null;\n        let pointLeft = null;\n        let pointRight = null;\n\n        for (let i = 0; i < data.length; i++) {\n          if (i === data.length - 1 || data[i].x > clientX && i === 0) {\n            pointLeft = data[i];\n            pointRight = data[i];\n          } else if (data[i].x > clientX) {\n            pointRight = data[i];\n            break;\n          } else {\n            pointLeft = data[i];\n          }\n        }\n\n        if (clientX - pointLeft.x / this.dpr > pointRight.x / this.dpr - clientX) {\n          point = pointRight;\n        } else {\n          point = pointLeft;\n        }\n\n        this.moveFlag = true;\n      }\n\n      e.preventDefault();\n    });\n  } //初始化数据坐标点\n\n\n  initData(data, isReal, i) {\n    let xWidthStep = (this.canvas.width - this.yLabel[i][0].x - (this.config.yLabel.font.padding[1] + this.config.padding[1]) * this.dpr) / (data.length - 1);\n    data.forEach((item, index) => {\n      item.isReal = isReal || item.isReal;\n      item.x = this.yLabel[i][0].x + this.config.yLabel.font.padding[1] * this.dpr + xWidthStep * index;\n      item.y = this.calculateY(item.value, i);\n    });\n  }\n\n  getNewData(data) {\n    let points = [];\n    let divisions = (data.length - 1) * this.config.line.pointsPow;\n\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(OperationUtils.divide(d, divisions), divisions, data));\n    }\n\n    return points;\n  }\n\n  getPoint(t, divisions, data) {\n    const points = data;\n    const isRealI = OperationUtils.multiply(t, divisions) % this.config.line.pointsPow;\n    const p = OperationUtils.multiply(points.length - 1, t);\n    const intPoint = Math.floor(p);\n    const weight = p - intPoint;\n    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n    const p1 = points[intPoint];\n    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n    return {\n      isReal: isRealI === 0,\n      name: isRealI === 0 ? points[OperationUtils.divide(OperationUtils.multiply(t, divisions), this.config.line.pointsPow)].name : null,\n      info: isRealI === 0 ? points[OperationUtils.divide(OperationUtils.multiply(t, divisions), this.config.line.pointsPow)].info : {},\n      value: this.catmullRom(weight, p0.value, p1.value, p2.value, p3.value)\n    };\n  }\n\n  catmullRom(t, p0, p1, p2, p3) {\n    const v0 = OperationUtils.multiply(OperationUtils.sub(p2, p0), 0.5);\n    const v1 = OperationUtils.multiply(OperationUtils.sub(p3, p1), 0.5);\n    const t2 = OperationUtils.multiply(t, t);\n    const t3 = OperationUtils.multiply(t, t2);\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n  } // 连接点绘制线\n\n\n  drawLine(data, index) {\n    this.ctx.beginPath();\n    this.ctx.lineWidth = 1 * this.dpr;\n    this.ctx.strokeStyle = this.config.colors[index];\n    this.ctx.lineJoin = \"round\";\n    data.forEach(item => {\n      this.ctx.lineTo(item.x, item.y);\n    });\n    this.ctx.stroke();\n    this.ctx.closePath(); // if (this.config.line.points.show) {\n    //   data.forEach((item) => {\n    //     if (item.isReal) {\n    //       this.ctx.beginPath();\n    //       this.ctx.fillStyle = this.config.line.points.outside.color;\n    //       this.ctx.arc(\n    //         item.x,\n    //         item.y,\n    //         this.config.line.points.outside.r * this.dpr,\n    //         0,\n    //         2 * Math.PI\n    //       );\n    //       this.ctx.fill();\n    //       this.ctx.closePath();\n    //       this.ctx.beginPath();\n    //       this.ctx.fillStyle = this.config.line.points.insideArc.color;\n    //       this.ctx.arc(\n    //         item.x,\n    //         item.y,\n    //         this.config.line.points.insideArc.r * this.dpr,\n    //         0,\n    //         2 * Math.PI\n    //       );\n    //       this.ctx.fill();\n    //       this.ctx.closePath();\n    //     }\n    //   });\n    // }\n  } //初始化坐标系\n\n\n  initCoordinateSystem(data, index) {\n    data.forEach(item => {\n      if (typeof item.value === \"number\") {\n        if (item.value > this.dataValueMax[index]) {\n          this.dataValueMax[index] = item.value;\n        } else if (item.value < this.dataValueMin[index]) {\n          this.dataValueMin[index] = item.value;\n        }\n      }\n    });\n\n    if (this.dataValueMin[index] > 0) {\n      this.dataValueMin[index] = 0;\n    }\n\n    this.yLabel[index] = this.config.yLabel.isRounding ? this.buildYLabelRounding(index) : this.buildYLabel();\n    this.xLabel = this.buildXLabel(JSON.parse(JSON.stringify(this.data)), index);\n  } // x轴值处理\n\n\n  buildXLabel(data, index) {\n    let xLabels = [];\n\n    if (data.length === 1) {\n      this.config.xLabel.line.num = 1;\n      xLabels = data;\n    } else if (data.length === 2) {\n      this.config.xLabel.line.num = 2;\n      xLabels = data;\n    } else if (data.length < this.config.xLabel.line.num * 2 + (this.config.xLabel.line.num - 2)) {\n      this.config.xLabel.line.num = 2;\n      xLabels = [data[0], data[data.length - 1]];\n    } else {\n      let xLableStep = Math.floor((data.length - this.config.xLabel.line.num) / (this.config.xLabel.line.num - 1));\n\n      for (let i = 0; i < this.config.xLabel.line.num - 1; i++) {\n        xLabels.push(data[xLableStep * i + i]);\n      }\n\n      xLabels.push(data[data.length - 1]);\n    }\n\n    let y = this.canvas.height - (this.config.xLabel.font.padding[2] + this.config.padding[2]) * this.dpr;\n    let xWidthStep = (this.canvas.width - this.yLabel[index][0].x - (this.config.yLabel.font.padding[1] + this.config.padding[1]) * this.dpr) / (xLabels.length - 1);\n\n    for (let i = 0; i < xLabels.length; i++) {\n      xLabels[i].x = this.yLabel[index][0].x + this.config.yLabel.font.padding[1] * this.dpr + xWidthStep * i;\n      xLabels[i].y = y;\n      xLabels[i].textAlign = i === 0 ? \"left\" : i === xLabels.length - 1 ? \"right\" : \"center\";\n      xLabels[i].textBaseline = \"bottom\";\n    }\n\n    return xLabels;\n  } // 取整y轴值处理\n\n\n  buildYLabelRounding(index) {\n    let newMax = Math.ceil(this.dataValueMax[index] * 1000);\n    let newMin = Math.floor(this.dataValueMin[index] * 1000);\n    let difference = newMax - newMin;\n    let step = difference / this.config.yLabel.line.num;\n    let isShowNought = step; // 寻找距离0最近的y\n    // 小幅波动特殊处理\n    // 如果newMin > 0 则newMin距离0最近  如果小于可接受比例，则展示0\n    // 如果newMax < 0 则newMax距离0最近  如果小于可接受比例，则展示0\n    // 否则数据路过0 让y轴坐标线距离0最近的参数回归0\n\n    if (difference < 10) {\n      step = 10;\n      newMax = Math.ceil((newMax + 20) / 10) * 10;\n      newMin = newMax - step * this.config.yLabel.line.num;\n    }\n\n    let stepIndex = 1;\n\n    while (difference >= Math.pow(10, stepIndex + 1) * (this.config.yLabel.line.num - 1)) {\n      stepIndex++;\n    }\n\n    let ceilNumber = Math.pow(10, stepIndex);\n\n    if (newMin >= 0) {\n      if (newMin < isShowNought) {\n        newMax = Math.ceil(newMax / ceilNumber) * ceilNumber;\n        step = Math.ceil(newMax / this.config.yLabel.line.num / ceilNumber) * ceilNumber;\n\n        if (newMax % step) {\n          newMax = step * Math.ceil(newMax / step);\n        }\n\n        newMin = newMax - step * this.config.yLabel.line.num;\n      } else {\n        newMin = Math.floor(newMin / ceilNumber) * ceilNumber;\n        step = Math.ceil((newMax - newMin) / this.config.yLabel.line.num / ceilNumber) * ceilNumber;\n        newMax = newMin + step * this.config.yLabel.line.num;\n      }\n    } else if (newMax <= 0) {\n      if (-newMax < isShowNought) {\n        newMin = Math.floor(newMin / ceilNumber) * ceilNumber;\n        step = Math.ceil(-newMin / this.config.yLabel.line.num / ceilNumber) * ceilNumber;\n\n        if (-newMin % step) {\n          newMin = step * Math.floor(newMin / step);\n        }\n\n        newMax = newMin + step * this.config.yLabel.line.num;\n      } else {\n        newMax = Math.ceil(newMax / ceilNumber) * ceilNumber;\n        step = Math.ceil((newMax - newMin) / this.config.yLabel.line.num / ceilNumber) * ceilNumber;\n        newMin = newMax - step * this.config.yLabel.line.num;\n      }\n    } else {\n      // 计算到0的步时\n      let i = 0; // newMax = Math.ceil(newMax / ceilNumber) * ceilNumber;\n      // newMin = Math.floor(newMin / ceilNumber) * ceilNumber;\n\n      let newValue = newMax > -newMin ? -newMin : newMax;\n      let newValueOld = newValue;\n\n      while (newValue - step >= 0) {\n        newValue -= step;\n        i++;\n      }\n\n      let supplementValue1 = newValueOld - step * i;\n      let supplementValue2 = step * (i + 1) - newValueOld; // 让y轴坐标线距离0最近的参数回归0 加大step\n\n      if (i === 0) {\n        if (newMax > -newMin) {\n          step = Math.ceil(newMax / (this.config.yLabel.line.num - 1) / ceilNumber) * ceilNumber;\n          newMax = step * (this.config.yLabel.line.num - 1);\n          newMin = -step;\n        } else {\n          step = Math.ceil(-newMin / (this.config.yLabel.line.num - 1) / ceilNumber) * ceilNumber;\n          newMax = step;\n          newMin = -step * (this.config.yLabel.line.num - 1);\n        }\n      } else if (supplementValue1 > supplementValue2) {\n        if (newMax > -newMin) {\n          // 采用newMin计算进入 0上方步长小 用newMax加大step\n          step = Math.ceil(newMax / (this.config.yLabel.line.num - (i + 1)) / ceilNumber) * ceilNumber;\n          newMax = step * (this.config.yLabel.line.num - (i + 1));\n          newMin = newMax - step * this.config.yLabel.line.num;\n        } else {\n          // 采用newMax计算进入 0下方步长小 用newMin加大step\n          step = Math.ceil(-newMin / (this.config.yLabel.line.num - (i + 1)) / ceilNumber) * ceilNumber;\n          newMin = -step * (this.config.yLabel.line.num - (i + 1));\n          newMax = newMin + step * this.config.yLabel.line.num;\n        }\n      } else {\n        if (newMax > -newMin) {\n          // 采用newMin计算进入 0下方步长小 用newMin加大step\n          step = Math.ceil(-newMin / i / ceilNumber) * ceilNumber;\n          newMin = -step * i;\n          newMax = newMin + step * this.config.yLabel.line.num;\n        } else {\n          // 采用newMax计算进入 0上方步长小 用newMax加大step\n          step = Math.ceil(newMax / i / ceilNumber) * ceilNumber;\n          newMax = step * i;\n          newMin = newMax - step * this.config.yLabel.line.num;\n        }\n      }\n    }\n\n    this.dataValueMax[index] = newMax / 1000;\n    this.dataValueMin[index] = newMin / 1000;\n    step = step / 1000;\n    return this.buildYLabel(step, index);\n  } // y轴值处理\n\n\n  buildYLabel(step, index) {\n    if (!step) {\n      let difference = this.dataValueMax[index] - this.dataValueMin[index];\n      step = difference / this.config.yLabel.line.num;\n    }\n\n    this.ctx.font = this.config.yLabel.font.size * this.dpr + \"px \" + this.config.yLabel.font.family;\n    let dataValueMaxTextWidth = this.ctx.measureText((this.dataValueMax[index] > 0 ? \"+\" : \"\") + this.dataValueMax[index].toFixed(2)).width;\n    let dataValueMinTextWidth = this.ctx.measureText((this.dataValueMax[index] > 0 ? \"+\" : \"\") + this.dataValueMin[index].toFixed(2)).width;\n    let yLableTextWidth = (dataValueMaxTextWidth > dataValueMinTextWidth ? dataValueMaxTextWidth : dataValueMinTextWidth) + (this.config.padding[3] + this.config.yLabel.font.padding[3]) * this.dpr;\n    let cur = \"\";\n    let yLabels = [];\n\n    for (let i = 0; i <= this.config.yLabel.line.num; i++) {\n      cur = (this.dataValueMin[index] + i * step).toFixed(2);\n\n      if (+cur === 0) {\n        cur = \"0.00\";\n      } else if (+cur > 0) {\n        cur = `${cur}`;\n      }\n\n      yLabels.push({\n        value: cur,\n        x: yLableTextWidth,\n        y: this.calculateY(+cur, index),\n        textAlign: \"right\",\n        textBaseline: \"middle\"\n      });\n    }\n\n    return yLabels;\n  }\n\n  calculateY(value, index) {\n    return (this.config.yLabel.font.size / 2 + this.config.padding[0]) * this.dpr + (this.dataValueMax[index] - value) / (this.dataValueMax[index] - this.dataValueMin[index]) * (this.canvas.height / this.originData.length - (this.config.padding[0] + this.config.padding[2] + this.config.xLabel.font.size + this.config.xLabel.font.padding[0] + this.config.xLabel.font.padding[2] + this.config.yLabel.font.size / 2) * this.dpr) + this.canvas.height * index / this.originData.length;\n  } //绘制坐标系\n\n\n  drawCoordinateSystem(index) {\n    // 绘制y轴\n    if (this.config.yLabel.line.show) {\n      for (let i = 0; i < this.yLabel[index].length; i++) {\n        this.ctx.beginPath();\n        this.ctx.fillStyle = this.config.yLabel.font.color;\n        this.ctx.textAlign = this.yLabel[index][i].textAlign;\n        this.ctx.textBaseline = this.yLabel[index][i].textBaseline;\n        this.ctx.font = this.config.yLabel.font.size * this.dpr + \"px \" + this.config.yLabel.font.family;\n        this.ctx.fillText(this.yLabel[index][i].value, this.yLabel[index][i].x, this.yLabel[index][i].y);\n        this.ctx.closePath();\n      }\n    }\n  }\n\n}\n\n//# sourceURL=webpack://TimeSeriesInsightsChart/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	module.exports.TimeSeriesInsightsChart = __webpack_exports__;
/******/ 	
/******/ })()
;